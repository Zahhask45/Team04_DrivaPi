# .github/workflows/generate_verification_artifacts.yml
# Reusable workflow: build + run tests + run cppcheck + (optional) coverage
# Caller must ensure either: use_cmake=true and CMakeLists.txt exists OR provide build_cmd.
on:
  workflow_call:
    inputs:
      use_cmake:
        type: boolean
        required: false
        default: true
      cmake_build_dir:
        type: string
        required: false
        default: build
      build_type:
        type: string
        required: false
        default: Debug
      build_cmd:
        type: string
        required: false
        default: ""
      test_cmd:
        type: string
        required: false
        default: ""
      test_binary:
        type: string
        required: false
        default: build/motor_speed_test
      junit_output:
        type: string
        required: false
        default: artifacts/verification/tests/LLTC-998-junit.xml
      coverage_output:
        type: string
        required: false
        default: artifacts/verification/coverage/coverage-SWD-998.xml
      cppcheck_output:
        type: string
        required: false
        default: artifacts/verification/static-analysis/cppcheck-SWD-998.xml
      src_dirs:
        type: string
        required: false
        default: src
      run_coverage:
        type: boolean
        required: false
        default: true
      run_cppcheck:
        type: boolean
        required: false
        default: true

jobs:
  generate-artifacts:
    runs-on: ubuntu-latest
    outputs:
      junit_path: ${{ steps.set_outputs.outputs.junit_path }}
      coverage_path: ${{ steps.set_outputs.outputs.coverage_path }}
      cppcheck_path: ${{ steps.set_outputs.outputs.cppcheck_path }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system deps
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake cppcheck

      - name: Setup tools (coverage)
        if: ${{ inputs.run_coverage == true }}
        run: |
          python -m pip install --upgrade pip
          pip install gcovr

      - name: Create artifact dirs
        run: |
          mkdir -p artifacts/verification/tests
          mkdir -p artifacts/verification/coverage
          mkdir -p artifacts/verification/static-analysis
          mkdir -p ${{ inputs.cmake_build_dir }}

      - name: Build (CMake or build_cmd)
        id: build
        run: |
          set -euo pipefail
          if [ "${{ inputs.use_cmake }}" = "true" ]; then
            FOUND=$(find . -maxdepth 3 -name CMakeLists.txt | head -n 1 || true)
            if [ -n "$FOUND" ]; then
              SRC_DIR=$(dirname "$FOUND")
              echo "Using CMake from: $SRC_DIR"
              cmake -S "$SRC_DIR" -B "${{ inputs.cmake_build_dir }}" -DCMAKE_BUILD_TYPE="${{ inputs.build_type }}"
              cmake --build "${{ inputs.cmake_build_dir }}" -- -j$(nproc)
            else
              if [ -n "${{ inputs.build_cmd }}" ]; then
                echo "No CMakeLists found, running build_cmd"
                eval "${{ inputs.build_cmd }}"
              else
                echo "Error: no CMakeLists.txt and no build_cmd provided"
                exit 1
              fi
            fi
          else
            if [ -n "${{ inputs.build_cmd }}" ]; then
              echo "use_cmake=false -> running build_cmd"
              eval "${{ inputs.build_cmd }}"
            else
              echo "Error: use_cmake=false but no build_cmd provided"
              exit 1
            fi
          fi

      - name: Run tests -> JUnit XML
        id: run_tests
        run: |
          set -euo pipefail
          JUNIT="${{ inputs.junit_output }}"
          mkdir -p "$(dirname "$JUNIT")"
          if [ -n "${{ inputs.test_cmd }}" ]; then
            echo "Running test_cmd..."
            eval "${{ inputs.test_cmd }}"
          else
            BIN="${{ inputs.test_binary }}"
            if [ -x "$BIN" ]; then
              "$BIN" --gtest_output=xml:"$JUNIT"
            elif [ -x "${{ inputs.cmake_build_dir }}/${BIN##*/}" ]; then
              "${{ inputs.cmake_build_dir }}/${BIN##*/}" --gtest_output=xml:"$JUNIT"
            else
              echo "Error: test binary not found ($BIN). Provide test_cmd or correct test_binary."
              exit 1
            fi
          fi
          if [ ! -s "$JUNIT" ]; then
            echo "Error: junit xml not produced or empty ($JUNIT)"
            exit 1
          fi
          echo "junit_created=1" >> $GITHUB_OUTPUT

      - name: Generate coverage (gcovr)
        if: ${{ inputs.run_coverage == true }}
        id: coverage
        run: |
          set -euo pipefail
          COV="${{ inputs.coverage_output }}"
          mkdir -p "$(dirname "$COV")"
          GCDA_COUNT=$(find "${{ inputs.cmake_build_dir }}" -name "*.gcda" 2>/dev/null | wc -l || true)
          if [ "$GCDA_COUNT" -gt 0 ]; then
            gcovr -r . --object-directory="${{ inputs.cmake_build_dir }}" --xml -o "$COV"
          else
            echo "Error: no .gcda found; coverage cannot be generated (ensure build/tests run with coverage flags)"
            exit 1
          fi
          if [ ! -s "$COV" ]; then
            echo "Error: coverage xml empty ($COV)"
            exit 1
          fi

      - name: Run cppcheck
        if: ${{ inputs.run_cppcheck == true }}
        id: cppcheck
        run: |
          set -euo pipefail
          CPPCHECK="${{ inputs.cppcheck_output }}"
          mkdir -p "$(dirname "$CPPCHECK")"
          cppcheck --enable=all --suppress=missingIncludeSystem --xml --xml-version=2 ${{ inputs.src_dirs }} 2> "$CPPCHECK" || true
          if [ ! -s "$CPPCHECK" ]; then
            echo "Error: cppcheck xml empty ($CPPCHECK)"
            exit 1
          fi

      - name: Set outputs
        id: set_outputs
        run: |
          echo "junit_path=${{ inputs.junit_output }}" >> $GITHUB_OUTPUT
          echo "coverage_path=${{ inputs.coverage_output }}" >> $GITHUB_OUTPUT
          echo "cppcheck_path=${{ inputs.cppcheck_output }}" >> $GITHUB_OUTPUT

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: verification-artifacts
          path: |
            artifacts/verification/tests/
            artifacts/verification/coverage/
            artifacts/verification/static-analysis/
